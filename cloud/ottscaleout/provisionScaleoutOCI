#!/usr/bin/env python2
# Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
#
# Licensed under the Universal Permissive License v 1.0 as shown
# at http://oss.oracle.com/licenses/upl

import time
import logging
import argparse
import re
import os
import sys
import shutil
import tempfile
import fnmatch
import subprocess
import zipfile
import uuid
import itertools
import glob
import urllib2
import json
import os.path as path
import signal
from functools import partial
from operator import itemgetter
from collections import OrderedDict
from pprint import pprint
from datetime import datetime
from itertools import chain
from distutils.spawn import find_executable
from distutils.dir_util import copy_tree,remove_tree
from os.path import expanduser,dirname
from shutil import copyfile
from shutil import move
from random import randint
from subprocess import PIPE, STDOUT
from tempfile import mkstemp

# trap ctrl-c and dump any provisioned resources
def signal_handler(cfgdata, signal, frame):
  if list_resources(cfgdata[0],cfgdata[1],1):
    warning = """
***** WARNING *****

The resources above were provisioned. It is recommended that you
destroy them by running the following command :

    cd /home/opc/timesten/%s && ./provisionScaleoutOCI -destroy

"""
    print warning % (cfgdata[1])

  elif os.path.exists(tf_script_home):
    if service_name:
      remove_terraform_dir()

  sys.exit(1)

try:
  import oci
except ImportError:
  print("\nThe OCI SDK for Python must be installed prior to running this utility.\n")
  print("To install the prerequisites for this utility, run this command :\n\nsudo yum " + \
        "install -y python-oci-sdk python-oci-cli terraform\n\nOn other platforms, or for more information, see :\n")
  print("https://docs.cloud.oracle.com/iaas/Content/API/SDKDocs/cliinstall.htm\n")
  sys.exit()

logging.basicConfig()

def get_args():

  parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
  parser.add_argument('-accept', action="count", required=False, help='Accept license agreements without prompting')
  parser.add_argument('-distro', required=False, help='Path to the TimesTen Scaleout distribution')
  parser.add_argument('-dataInstanceShape', required=False, help='VM shape for data instances')
  parser.add_argument('-replicaSets', required=False, type=int, help='Number of replica sets to create')
  parser.add_argument('-serviceName', required=False, help='Name of service')
  parser.add_argument('-compartment', required=False, help='Name of the compartment to use')
  parser.add_argument('-region', required=False, help='Name of the OCI region to use')
  parser.add_argument('-ad', required=False, help='Create instances in this Availability Domain (also sets starting AD when spanning ADs)')
  parser.add_argument('-spanAD', action="count", required=False, help='Data instances should span Availability Domains (use -ad to specify starting AD)')
  parser.add_argument('-osImage', required=False, help='Name of the OCI image to use')
  parser.add_argument('-blockSize', required=False, help='Create block storage devices of this size (in GB)')
  parser.add_argument('-batch', action="count", required=False, help='Accept all defaults with no user interaction.')
  parser.add_argument('-destroy', action="count", required=False, help='Destroy service')
  parser.add_argument('-useLocal', action="count", required=False, help='Modify and use files in the current directory')
  parser.add_argument('-trialAccount', action="count", required=False, help='Configure for an OCI Trial/Pay-as-you-go account')
  parser.add_argument('-version', action="count", required=False, help='Print version and exit')

  return vars(parser.parse_args())

def main():

  global version
  global args
  global timesten_bin
  global home_dir
  global tf_script_home
  global oci_config_file
  global running_in_distro
  global service_name
  global trial_account
  global ansible_status
  global terraform_status
  global current_tt_version
  global ksafety
  global supported_denseio
  global supported_stdio
  global permsize_mb
  global tempsize_mb
  global trial_bastion_initial_ad
  global trial_initial_ad
  global trial_bootstrap_ad

  args = get_args()

  if args["version"]:
    dump_version()
    sys.exit(0)

  bastion_pub_ip = None

  # default values
  permsize_mb = 4096
  tempsize_mb = 400
  ksafety = 2

  trial_bastion_initial_ad = None
  trial_initial_ad = None
  trial_bootstrap_ad = None

  ##############################################################
  # SUPPORTED VM SHAPES
  # - values: "OCI LABEL FOR SHAPE", "# OF OCPUs", "MEMORY IN GB"
  #
  # TODO: VALUES FOR VM SHAPES (OCPU, MEM) WILL BE DETERMINED VIA
  #       THE OCI API WHEN SUCH FUNCTIONALITY IS SUPPORTED
  ##############################################################
  supported_denseio = OrderedDict([('VM.DenseIO2.8',[8,120]),('VM.DenseIO2.16',[16,240]),
                                  ('VM.DenseIO2.24',[24,320]),('BM.DenseIO2.52',[52,768])])

  supported_stdio = OrderedDict([('VM.Standard2.2',[2,30]),('VM.Standard2.4',[4,60])])
  ###############################################################

  home_dir = expanduser("~")
  timesten_bin = home_dir + '/timesten'

  if os.path.exists(os.getcwd() + '/terraform.tfstate') and not args["destroy"]:
    print("\nERROR: The current directory contains files modified outside of this utility. The only supported option is '-destroy'\n")
    sys.exit(1)

  if os.path.exists(os.getcwd() + '/../bin/ttVersion'):
    running_in_distro = 1
    current_tt_version = get_tt_version()
  else:
    running_in_distro = 0

  if not os.path.exists(timesten_bin):
    os.makedirs(timesten_bin)

  #if not args["destroy"] and not args["accept"]:
  #  answer = raw_input("\nDo you accept the license and terms of use for the components listed in the included\n" + \
  #                     "README as well as the license and terms for the TimesTen Scaleout product ? [yes/no] ")

  #  if not re.search('^(yes)$', answer.lower()):
  #    print("\nYou must accept the license terms to proceed.\n")
  #    sys.exit(1)

  ###################################
  # CHECK COMMAND LINE OPTIONS
  ###################################
  #check_command_line_options()

  ###################################
  # CHECK ORACLE LINUX VERSION
  ###################################
  check_oracle_linux()

  ###################################
  # SETUP OCI CONFIG
  ###################################
  oci_config_file = home_dir + "/.oci/config"
  setup_oci_conf()

  oci_config = oci.config.from_file()
  user_ocid = oci_config["user"]
  default_region = oci_config["region"]
  tenancy_ocid = oci_config["tenancy"]
  fingerprint = oci_config["fingerprint"]
  priv_key_path = oci_config["key_file"]

  ##################################
  # TEST API CONFIG
  ##################################
  if not test_api(oci_config):
    print("\nERROR: A failure was encountered while trying to retrieve the compartment list for your tenancy from OCI.\n\n" + \
          "It is recommended that you validate the configuration in " + oci_config_file + \
          " and run this utility again.\n\nMore information can be found here :\n\nhttps://docs.cloud.oracle.com/iaas/Content/API/Concepts/sdkconfig.htm\n")
    sys.exit(1)

  ###################################
  # SETUP LOCAL SSH KEYS
  ###################################
  setup_ssh()

  #################################################
  # FIND/GET THE SCALEOUT TERRAFORM/ANSIBLE SCRIPTS
  #################################################
  tf_script_home = find_scaleout_scripts(oci_config)
  script_dirname = os.path.basename(tf_script_home)

  ###################################
  # FIND/GET TERRAFORM
  ###################################
  terraform_bin = find_terraform(oci_config)

  ###################################
  # terraform -destroy
  ###################################
  if args["destroy"]:

    cannot_destroy_msg = """
***** WARNING *****

Since the current directory does not contain a terraform.tfstate file,
the resources listed above must be terminated manually through the OCI web console.

To remove block volumes : Menu->Block Storage->Block Volumes->Terminate

To remove instances : Menu->Compute->Instances->Terminate

To remove boot volumes : Menu->Compute->Boot Volumes>Terminate

To remove Virtual Networks (VCNs) : Menu->Networking->Virtual Cloud Networks->Terminate
* related resources (Route Tables, Security Lists and Subnets) will be removed
  automatically when the VCN is removed

"""

    if not os.path.exists(tf_script_home + "/terraform.tfstate"):
      # if we're in a previously provisioned script dir (script_dirname (basename) will be the service name)
      if script_dirname != 'ottscaleout' and list_resources(oci_config,script_dirname,0):
        print(cannot_destroy_msg)
      else:
        print("\nCannot locate " + tf_script_home + "/terraform.tfstate (nothing to destroy).\n" + \
              "\nThis command must be run from the directory that was used to provision this service.\n")
        if os.path.exists(os.getcwd() + "/timesten"):
          print("This directory may be located in " + os.getcwd() + "/timesten\n")

      sys.exit(1)

    if not args["batch"]:
      answer = raw_input("Are you sure you want to proceed with the destroy operation ? [n] ")
    else:
      answer = 'y'

    if re.search(r'(y|yes)', answer.lower()):
      print("\nRunning 'terraform destroy' in " + tf_script_home + "...\n")
      destroy_start = datetime.now().replace(microsecond=0)

      sys.stdout.flush()
      process = subprocess.Popen("cd " + tf_script_home + " && source " + tf_script_home + "/env-vars && " +
                                  terraform_bin + " destroy -force", stdout=subprocess.PIPE, shell=True)

      while True:
        nextline = process.stdout.readline()
        if nextline == '' and process.poll() is not None:
            break
        sys.stdout.write(nextline)
        sys.stdout.flush()

      out = process.communicate()
      status = process.wait()
      if status == 0:
        destroy_elapsed = datetime.now().replace(microsecond=0) - destroy_start
        print("\nDestroy time was {}".format(destroy_elapsed))
        if not re.search("_destroyed", tf_script_home):
          if os.path.exists(tf_script_home + "_destroyed"):
            # if there's already a _destroyed dir, append epoch
            os.rename(tf_script_home, tf_script_home + "_destroyed" + "_" + str(int(time.time())))
          else:
            os.rename(tf_script_home, tf_script_home + "_destroyed")
        sys.exit(status)
      else:
        print("\n** ERROR: FAILED to execute 'terraform -destroy'!\n")
        if script_dirname != 'ottscaleout' and list_resources(oci_config,script_dirname,1):
          print(cannot_destroy_msg)
        sys.exit(status)

    else:
      sys.exit(0)

  ############################
  # DETERMINE OCI ACCOUNT TYPE
  # - trial or pay-as-you-go?
  ############################
  trial_account = is_trial_account()

  if trial_account == 'yes':
    bootstrap_meta = get_bootstrap_metadata()
    if bootstrap_meta:
      if "availabilityDomain" in bootstrap_meta:
        # ex: NIbo:PHX-AD-1 or NIbo:US-ASHBURN-AD-1
        # trial : iEoU:US-ASHBURN-AD-1
        m = re.match(".+-AD-(\d+)", bootstrap_meta["availabilityDomain"])
        if m and m.group(1):
          trial_bootstrap_ad = int(m.group(1))
          trial_bootstrap_ad = trial_bootstrap_ad - 1
          trial_bastion_initial_ad = ((trial_bootstrap_ad +1) % 3) + 1
          trial_initial_ad = (trial_bastion_initial_ad % 3) + 1
        else:
          print("\nERROR: Unable to determine the 'Availability Domain' that you are running in.\n" + \
                "\nThis utility must be run from an OCI compute instance running in a valid 'Availability Domain'\n\n")
          sys.exit(1)
    else:
      print("\nERROR: This machine is not an OCI Compute Instance.\n" + \
            os.path.basename(__file__) + " is intended to be run from an OCI instance.\n")
      sys.exit(1)

  ###########################
  # DETERMINE SERVICE NAME
  ###########################
  service_name = get_service_name(oci_config)
  print("\nService name set to \'%s\'" % service_name)

  # register signal handler now that we have a service name to perform a resource check with
  signal.signal(signal.SIGINT, partial(signal_handler, [ oci_config, service_name ]))

  ########################################
  # COPY SCRIPTS DIRECTORY
  ########################################
  if not args["useLocal"]:
    tf_script_home = copy_scaleout_scripts(service_name)

  ###########################
  # DETERMINE COMPARTMENT
  ###########################
  compartment = get_compartment(oci_config)
  print("\nCompartment set to \'%s\'" % str(compartment["name"]))

  ###########################
  # DETERMINE REGION
  ###########################
  if trial_account == 'yes' and "canonicalRegionName" in bootstrap_meta:
    region = bootstrap_meta["canonicalRegionName"]
  else:
    region = get_region(oci_config,compartment["id"])
    print("\nRegion set to \'%s\'" % str(region))

  ################################
  # DETERMINE WHETHER TO SPAN ADs
  ################################
  if trial_account == 'yes':
    single_ad = False
  else:
    single_ad = get_single_ad_config()
    if single_ad == True:
      print("\nData instances will NOT span 'Availability Domains'")
    else:
      print("\nData instances will span 'Availability Domains'")

  ################################
  # DETERMINE WHICH AD
  ################################
  if trial_account == 'yes':
    # maps to initialAD in variables.tf
    specific_ad = 1
    try:
      start_ad = trial_initial_ad
    except:
      print("\nWARNING: Could not determine which 'Availiablity Domain' to start with. Setting to 1.\n")
      start_ad = 1
  else:
    if single_ad == True:
      specific_ad = get_specific_ad()
    else:
      specific_ad = None
      start_ad = get_starting_ad()
      print("\nSpanned data instances will start in 'Availability Domain' : " + str(start_ad))

  ###################################################################
  # UPDATE API CONFIG WITH REGION
  # IMPORTANT : since the region may have changed based on the user input above,
  # we must update the api config loaded earlier
  ###################################################################
  replace_value_in_oci_config(oci_config, 'region', str(region))

  ###########################
  # DETERMINE OS IMAGE
  ###########################
  os_image = get_os_image(oci_config,compartment["id"])
  #print("\nOS Image set to \'%s\'" % os_image.display_name)

  ###################################
  # DETERMINE TIMESTEN DISTRO VERSION
  ###################################
  scaleout_distro = get_scaleout_distro(oci_config)
  if scaleout_distro == None:
    remove_terraform_dir()
    sys.exit(1)

  if trial_account == 'yes':
    num_replica_sets = 1
    num_data_instances = (num_replica_sets * 2)
  else:
    num_replica_sets = get_num_replica_sets()
    num_data_instances = (num_replica_sets * 2)
  print("\nNumber of replica sets = " + str(num_replica_sets) + " (" + str(num_data_instances) + " data instances)")

  ################################
  # DETERMINE DATA INSTANCE SHAPE
  ################################
  if trial_account == 'yes':
    di_shape = "VM.Standard2.2"
  else:
    di_shape = get_data_instance_shape(oci_config,region,compartment["id"],os_image.id)
    print("\nData instances will use shape : " + str(di_shape))

  (permsize_mb, tempsize_mb) = calculate_db_size(di_shape, permsize_mb, tempsize_mb)

  if not re.search("Dense", di_shape):
    # variable "diBlockVolumeSizeGB" { default = "0" }
    block_vol_size_gb = get_block_volume_size(di_shape)
    print("\nBlock volume size will be " + str(block_vol_size_gb) + "GB")
  else:
    block_vol_size_gb = None

  ##############################################################
  # MODIFY FILE: env-vars
  ##############################################################
  env_script = tf_script_home + '/env-vars'
  if not os.path.exists(env_script):
    print("\nERROR: Cannot locate " + env_script + "\n\nRe-install the provisionScaleoutOCI " +
          "distribution and run again.\n\n")
    remove_terraform_dir()
    sys.exit(1)

  os.rename(env_script, env_script + '.orig')
  destination = open( env_script, "w" )
  source = open( env_script + '.orig', "r" )
  for line in source:
      if re.search("^export[ \t]+TF_VAR_user_ocid[ \t]?=", line):
        destination.write("export TF_VAR_user_ocid=\"" + user_ocid + "\"\n")
      elif re.search("^export[ \t]+TF_VAR_region[ \t]?=", line):
        destination.write("export TF_VAR_region=\"" + str(region) + "\"\n")
      elif re.search("^export[ \t]+TF_VAR_service_name[ \t]?=", line):
        destination.write("export TF_VAR_service_name=\"" + service_name + "\"\n")
      elif re.search("^export[ \t]+TF_VAR_tenancy_ocid[ \t]?=", line):
        destination.write("export TF_VAR_tenancy_ocid=\"" + tenancy_ocid + "\"\n")
      elif re.search("^export[ \t]+TF_VAR_fingerprint[ \t]?=", line):
        destination.write("export TF_VAR_fingerprint=\"" + fingerprint + "\"\n")
      elif re.search("^export[ \t]+TF_VAR_private_key_path[ \t]?=", line):
        destination.write("export TF_VAR_private_key_path=\"" + priv_key_path + "\"\n")
      elif re.search("^export[ \t]+TF_VAR_compartment_ocid[ \t]?=", line):
        destination.write("export TF_VAR_compartment_ocid=\"" + str(compartment["id"]) + "\"\n")
      else:
        destination.write( line )

  source.close()
  destination.close()

  ##############################################################
  # MODIFY FILE: variables.tf
  ##############################################################
  vars_script = tf_script_home + '/variables.tf'
  if not os.path.exists(vars_script):
    print("\nERROR: Cannot locate " + vars_script + "\n\nRe-install the provisionScaleoutOCI " +
          "distribution and run again.\n\n")
    remove_terraform_dir()
    sys.exit(1)

  try:
    os.rename(vars_script, vars_script + '.orig')
  except:
    print("\nERROR: Failed to rename " + vars_script + " to " + vars_script + ".orig.\n\nPlease set the " +
          "appropriate permissions and run this utility from within the provisionScaleoutOCI directory.\n\n")
    remove_terraform_dir()
    sys.exit(1)

  destination = open( vars_script, "w" )
  source = open( vars_script + '.orig', "r" )

  for line in source:
    if re.search("#[ \t]*Oracle-Linux-", line):
      destination.write("    #  " + os_image.display_name + "\n")
    elif re.search("\"" + str(region) + "\"", line):
      destination.write("    \"" + str(region) + "\"  = \"" + os_image.id + "\"\n")
    elif re.search("\"diInstanceCount\"", line):
      destination.write("variable  \"diInstanceCount\" { default = \"" + str(num_replica_sets) + "\" }\n")
    elif re.search("\"diInstanceShape\"", line):
      destination.write("variable  \"diInstanceShape\" { default = \"" + di_shape + "\" }\n")
    elif re.search("\"diBlockVolumeSizeGB\"", line) and block_vol_size_gb is not None:
      destination.write("variable  \"diBlockVolumeSizeGB\" { default = \"" + str(block_vol_size_gb) + "\" }\n")
    elif re.search("\"singleAD\"", line) and single_ad:
      destination.write("variable  \"singleAD\" { default = \"true\" }\n")
    elif re.search("\"initialAD\"", line) and trial_account == 'yes' and trial_initial_ad:
      destination.write("variable  \"initialAD\" { default = \"" + str(trial_initial_ad) + "\" }\n")
    elif re.search("\"initialAD\"", line) and specific_ad:
      destination.write("variable  \"initialAD\" { default = \"" + str(specific_ad) + "\" }\n")
    elif re.search("\"initialAD\"", line) and start_ad:
      destination.write("variable  \"initialAD\" { default = \"" + str(start_ad) + "\" }\n")
    #elif re.search("\"bsInstanceInitialAD\"", line) and specific_ad:
    #  destination.write("variable  \"bsInstanceInitialAD\" { default = \"" + str(specific_ad) + "\" }\n")
    elif re.search("\"bsInstanceInitialAD\"", line) and trial_bastion_initial_ad:
      destination.write("variable  \"bsInstanceInitialAD\" { default = \"" + str(trial_bastion_initial_ad) + "\" }\n")
    elif re.search("\"permsize_mb\"", line):
      destination.write(" " * 4 + "\"permsize_mb\"" + " " * 13 + "=  " + str(permsize_mb) + "\n")
    elif re.search("\"tempsize_mb\"", line):
      destination.write(" " * 4 + "\"tempsize_mb\"" + " " * 13 + "=  " + str(tempsize_mb) + "\n")
    else:
      destination.write( line )

  source.close()
  destination.close()

  print("\n-- SUMMARY --\n")
  print('{0:<37} {1:<40}'.format("Service Name",str(service_name)))
  if "display_name" in scaleout_distro:
    print('{0:<37} {1:<40}'.format("Scaleout Install",str(os.path.basename(scaleout_distro["display_name"]))))
  else:
    print('{0:<37} {1:<40}'.format("Scaleout Install",str(os.path.basename(scaleout_distro))))
  print('{0:<37} {1:<40}'.format("Compartment",str(compartment["name"])))
  print('{0:<37} {1:<40}'.format("Region",str(region)))
  print('{0:<37} {1:<40}'.format("OS Image",os_image.display_name))
  print('{0:<37} {1:<40}'.format("Data Instance Shape",str(di_shape)))
  if single_ad == True:
    print('{0:<37} {1:<40}'.format("Span Availability Domains","No (AD-" + str(specific_ad) +")"))
  else:
    if str(start_ad) == "3":
      print('{0:<37} {1:<40}'.format("Span Availability Domains","Yes (AD-3->AD-1)"))
    else:
      print('{0:<37} {1:<40}'.format("Span Availability Domains","Yes (AD-" + str(start_ad) + "->AD-" + str(int(start_ad)+1) + ")"))
  print('{0:<37} {1:<40}'.format("Database Size",str(int(permsize_mb / 1024)) + "GB"))
  if block_vol_size_gb:
    print('{0:<37} {1:<40}'.format("Block volume size",str(block_vol_size_gb) + "GB"))
  print('{0:<37} {1:<40}'.format("Number of Replica Sets",str(num_replica_sets)))
  print('{0:<37} {1:<40}'.format("Number of Data Instances",str(num_data_instances)))
  print('{0:<37} {1:<40}'.format("TOTAL NUMBER OF COMPUTE INSTANCES",str(int(num_data_instances + 1)) + " (" + str(num_data_instances) + " data + 1 bastion)"))

  while True:
    if args["batch"]:
      print("\n** PROVISIONING WILL BEGIN IN 10 SECONDS - CTRL-C TO STOP **\n")
      for i in xrange(10,0,-1):
        sys.stdout.write(str(i)+' ')
        sys.stdout.flush()
        time.sleep(1)
      print("\n")
      break
    else:
      answer = raw_input("\nProceed ? [ y ] ")

    if answer.lower() in ('y','yes',''):
      break
    elif answer.lower() in ('n','no'):
      remove_terraform_dir()
      sys.exit(1)

  print("\nRunning Terraform ...")
  provision_start = datetime.now().replace(microsecond=0)
  t_init_cmd = "source " + tf_script_home + "/env-vars && cd " + tf_script_home + " && " + terraform_bin + " init > " + tf_script_home + "/init.out 2>&1"
  print "- 'terraform init' : ",
  sys.stdout.flush()
  process = subprocess.Popen(t_init_cmd, stdout=subprocess.PIPE, shell=True)
  stdout, stderr = process.communicate()
  status = process.wait()
  if status == 0:
    print("OK (" + tf_script_home + "/init.out)")
  else:
    print("\n** ERROR: FAILED to execute 'terraform init'!\n")
    print("\n" + stdout.decode("utf-8"))
    sys.exit(1)

  ##############################################################
  # RUN: TERRAFORM PLAN
  ##############################################################
  t_plan_cmd = "source " + tf_script_home + "/env-vars && cd " + tf_script_home + " && " + terraform_bin + " plan -out " + tf_script_home + "/plan.out"
  print "- 'terraform plan' : ",
  sys.stdout.flush()
  process = subprocess.Popen(t_plan_cmd, stdout=subprocess.PIPE, shell=True)
  stdout, stderr = process.communicate()
  status = process.wait()
  if status == 0:
    print("OK (" + tf_script_home + "/plan.out)")
  else:
    print("\nFAILED to execute 'terraform plan'")
    print("\n" + stdout.decode("utf-8"))
    sys.exit(1)

  ##############################################################
  # RUN: TERRAFORM APPLY
  ##############################################################
  apply_start = datetime.now().replace(microsecond=0)
  t_apply_log = tf_script_home + "/apply.out"
  t_apply_cmd = "source " + tf_script_home + "/env-vars && cd " + tf_script_home + " && " + terraform_bin + " apply --auto-approve"
  print "- 'terraform apply': ",
  sys.stdout.flush()
  svc_limit_exceeded = 0
  oci_not_authorized = 0
  process = subprocess.Popen(t_apply_cmd, stdout=PIPE, stderr=STDOUT, bufsize=1, shell=True)
  with process.stdout, open(t_apply_log, 'ab') as outfile:
    for line in iter(process.stdout.readline, b''):
      outfile.write(line)
      if re.search("Service error:LimitExceeded", line):
        svc_limit_exceeded = 1
      elif re.search("Service error:NotAuthorizedOrNotFound", line):
        oci_not_authorized = 1
  terraform_status = process.wait()
  if terraform_status == 0:
    apply_elapsed = datetime.now().replace(microsecond=0) - apply_start
    print("OK (" + t_apply_log +")")
    print("\nTerraform runtime was {}".format(apply_elapsed))
  else:
    print("FAILED\n")
    if svc_limit_exceeded:
      error_msg = """
#### ERROR ####

You have reached a service limit for one of the OCI resources selected.

See the following log :

"""
      print(error_msg + "\t" + t_apply_log + "\n")

    elif oci_not_authorized:
      error_msg = """
### ERROR ####

Insufficient privileges or resources.

See the following log :

"""
      print(error_msg + "\t" + t_apply_log + "\n")
    else:
      print("\n\nFAILED to execute 'terraform apply'. See log in " + tf_script_home + "/apply.out\n\n")
    failure_msg()
    # list the provisioned resources
    list_resources(oci_config,service_name,1)
    sys.exit(1)

  bastion_pub_ip = get_bastion_ip(oci_config,compartment["id"],service_name,'public')

  if bastion_pub_ip == None:
    print("\n\nERROR: Cannot determine IP address of bastion server.")
    failure_msg()
    # list the provisioned resources
    list_resources(oci_config,service_name,1)
    sys.exit(1)


  ##############################################################
  # RUN: ANSIBLE
  ##############################################################
  ansible_start = datetime.now().replace(microsecond=0)
  ansible_cmd = "ssh -oStrictHostKeyChecking=no -oBatchMode=yes -l opc " + bastion_pub_ip + " \"cd service/ansible && ansible-playbook -i ./hosts rollout.yaml\""
  ansible_cmd_full = ansible_cmd + " > " + tf_script_home + "/ansible.out 2>&1"
  print("\nRunning Ansible scripts on remote host (" + tf_script_home + "/ansible.out)")
  print("\nThis step may take longer than 10 minutes.\n")
  sys.stdout.flush()
  process = subprocess.Popen(ansible_cmd_full, stdout=subprocess.PIPE, shell=True)
  stdout, stderr = process.communicate()
  ansible_status = process.wait()
  if ansible_status == 0:
    print("OK (" + tf_script_home + "/ansible.out)")
    ansible_elapsed = datetime.now().replace(microsecond=0).replace(microsecond=0) - ansible_start
    print("\nAnsible runtime was {}".format(ansible_elapsed))
    if os.path.exists(tf_script_home + "/terraform.tfstate"):
      process_tfstate(tf_script_home + "/terraform.tfstate")
  else:
    print("\nFAILED :\n\n" + ansible_cmd_full + "\n\nSee log : " + tf_script_home + "/ansible.out")
    print("\nTo re-run :\n\n" + ansible_cmd + "\n\n")
    failure_msg()
    # list the provisioned resources
    list_resources(oci_config,service_name,1)

  cleanup_terraform_dir()

  provision_elapsed = datetime.now().replace(microsecond=0) - provision_start
  print("Total provisioning time was {}".format(provision_elapsed) + "\n")
  sys.exit(ansible_status)

#############################################################################################################

def check_oracle_linux():

  default = "yes"
  is_ol7 = 0
  is_oci = 0

  cmd = "curl -m 10 -s -L http://169.254.169.254/opc/v1/instance/"
  try:
    out = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
    meta = json.loads(out)
    if "canonicalRegionName" in meta:
      is_oci = 1
      if os.path.exists('/etc/oracle-release'):
        ver = subprocess.check_output("cat /etc/oracle-release",shell=True)
        if re.search("^Oracle[ \t]+Linux.+\s7\.", ver.decode("utf-8")):
          is_ol7 = 1
  except subprocess.CalledProcessError as e:
    pass

  if not is_ol7 or not is_oci:
    print("\n***** WARNING: This utility is intended to be run on an Oracle Linux 7 OCI instance.\n")
    answer = raw_input("Do you want to continue ? [ " + default + " ] ")
    if answer.lower() in ('y','yes',''):
      return
    else:
      sys.exit(1)
  else:
    return

######################################################################
# failure_msg
######################################################################
def failure_msg():

  print("\nERROR: Failed to provision TimesTen Scaleout.\n\n" + \
        "Destroy any partially provisioned resources and retry.\n" + \
        "Destroy command : cd " + tf_script_home + " && ./" + os.path.basename(__file__) + " -destroy\n\n")


######################################################################
# get_single_ad_config
######################################################################
def get_single_ad_config():

  default = "1"
  answer = None

  print ("\nPlease select one of the following 'High Availability' options :\n\n" + \
         "1. Best performance  - all data instances in one 'Availability Domain'\n" + \
         "2. Best availability - data instances distributed across 'Availability Domains'\n")

  while True:
    if args["ad"] and not args["spanAD"]:
      answer = "1"
      break
    elif args["spanAD"]:
      answer = "2"
      break
    elif args["batch"]:
      answer = default
      break

    answer = raw_input("Which option would you like to choose ? [ " + str(default) + " ] ")

    if answer == '':
      answer = default
      break

    if answer not in ('1','2'):
      print("Invalid response. Valid responses are 1 or 2.")
      continue
    else:
      break

  if answer == "2":
    return False
  else:
    return True


######################################################################
# get_specific_ad
######################################################################
def get_specific_ad():

  default = 1
  answer = None

  while True:
    if args["ad"]:
      if args["ad"] not in ('1','2','3'):
        print("\nERROR: Invalid -ad option passed. Must be 1, 2 or 3.\n")
        sys.exit(1)
      answer = args["ad"]
      break
    elif args["batch"]:
      answer = default
      break

    answer = raw_input("\nWhich 'Availability Domain' do you want to use (1, 2, or 3) ? [ " + str(default) + " ] ")

    if answer == '':
      answer = default
      break

    if answer not in ('1','2','3'):
      print("Invalid response. Valid responses are 1, 2 or 3.")
      continue
    else:
      break

  return answer

######################################################################
# get_starting_ad
######################################################################
def get_starting_ad():

  default = 1
  answer = None

  print("\nOf the following three options :\n")
  print("1. 1->2\n2. 2->3\n3. 3->1\n")

  while True:
    try:
      if args["ad"]:
        if args["ad"] not in ('1','2','3'):
          print("\nERROR: Invalid -ad option passed. Must be 1, 2 or 3.\n")
          sys.exit(1)
        answer = args["ad"]
        break
      elif args["batch"]:
        answer = 1
        break
      else:
        answer = raw_input("Which 'Availability Domains' would you like to span ? [ " + str(default) + " ] ")

      if answer == '':
        answer = 1
        break
      elif answer not in ('1','2','3'):
        print("Invalid response. Valid responses are 1, 2 or 3.")
      else:
        break
    except IndexError as error:
      print("\nInvalid response.\n")
      continue

  return answer

######################################################################
# get_num_replica_sets
######################################################################
def get_num_replica_sets():

  default_repsets = 2
  min = 1
  max = 32

  desc = """
Number of Replica Sets
----------------------

* There are two data instances per replica set for high availability
* The number of data instances determines the database capacity and SQL parallelism

NOTE: Please check the OCI console's "Governance->Service Limits" page to ensure that
      you have sufficient resources to provision the desired number and type of compute instances.
"""

  print(desc)

  while True:
    if args["replicaSets"]:
      if not re.search("^(\d+)$", str(args["replicaSets"])):
        print("\nERROR: Invalid number of replica sets passed via the -replicaSets option.")
        sys.exit(1)
      else:
        answer = args["replicaSets"]
        break
    elif args["batch"]:
      answer = default_repsets
      break

    answer = raw_input("How many replica sets would you like to create (1 replica set = 2 data instances) ? [ " + str(default_repsets) + " ] ")

    if answer == '':
      answer = default_repsets
    elif int(answer) > max:
      print("The maximum number of replica sets is " + str(max) + ".\n")
      continue
    elif int(answer) < min:
      print("The minimum number of replica sets is " + str(min) + ".\n")
      continue

    if re.match("^([0-9]+)$", str(answer)):
      answer = int(answer)
      break
    else:
      print("Invalid response.")

  return answer

######################################################################
# get_block_volume_size
######################################################################
def get_block_volume_size(di_shape):

  # default block storage volume should be 3x MEMORY
  # will default to 100 here in the event we're dealing with an unknown VM config
  default = 100

  for i, d in enumerate(supported_stdio):
    if d == di_shape:
      # default block storage device = 3x MEMORY
      default = int(supported_stdio[d][1] * 3)

  while True:
    if args["blockSize"]:
      answer = args["blockSize"]
      break
    elif args["batch"] or trial_account == 'yes':
      answer = default
      break

    answer = raw_input("\nProvide the block volume size in GB (more than 50GB, less than 5000GB) ? [ " + str(default) + " ] ")
    if answer == '':
      answer = default

    if re.match("^([0-9]+)$", str(answer)):
      if int(answer) > 5000:
        print("\nProvide a block volume size of less than 5000GB.")
        continue
      elif int(answer) < 50:
        print("\nProvide a block volume size of at least 50GB.")
        continue
      break
    else:
      print("Provide a valid block volume size in GB.")

  return answer


######################################################################
# replace_value_in_oci_config
######################################################################
def replace_value_in_oci_config(config,key_to_find,definition):

  if key_to_find in config:
    config[key_to_find] = definition
  else:
    print("WARNING: Cannot locate/update the '" + key_to_find + "' parameter in the OCI config file.\n")


######################################################################
# calculate_db_size
######################################################################
def calculate_db_size(di_shape, permsize_mb, tempsize_mb):

  memory = None

  for known_shape in itertools.chain(supported_denseio,supported_stdio):
    if known_shape == di_shape:
      if re.search('DenseIO', known_shape):
        memory = supported_denseio[known_shape][1]
      elif str(known_shape) in supported_stdio:
        memory = supported_stdio[known_shape][1]

  if not memory:
    print("\nERROR: Cannot determine the memory size for OCI VM shape '" + di_shape + "'.\n\n" + \
          "The default database size is " + str(int(permsize_mb / 1024)) + "GB.\n")
    while True:
      answer = raw_input("Provide the database size in GB ? [" + str(int(permsize_mb / 1024)) + "] ")
      if answer == '':
        return (permsize_mb, tempsize_mb)
      if re.match("^([0-9]+)$", str(answer)):
        if int(answer) < 1:
          print("\nProvide a database size of at least 1GB.")
          continue
        permsize_mb = int(answer) * 1024
        break
      else:
        print("Provide a database size of at least 1GB.")

    return (permsize_mb, tempsize_mb)

  temp_permsize_mb = int(memory/2) * 1024
  temp_tempsize_mb = int((temp_permsize_mb * .10))

  return (temp_permsize_mb, temp_tempsize_mb)


######################################################################
# get_data_instance_shape
######################################################################
def get_data_instance_shape(config,selected_region,compartment_id,image_id):

  try:
    compute = oci.core.ComputeClient(config)
    response = oci.pagination.list_call_get_all_results(compute.list_shapes,compartment_id=compartment_id)
  except Exception as err:
    print("\nERROR: Failed to request list of compute shapes from OCI.\n\n\"%s\n\"" % str(err))
    sys.exit(1)

  shapes = []
  standardio = []
  denseio = []
  other = []
  default = str(1)
  match = None
  answer = ''
  shape_missing = 0

  # if dataInstanceShape was passed, make sure the api knows about this shape
  for shape in response.data:
    if args["dataInstanceShape"]:
      if args["dataInstanceShape"] == shape.shape:
        # the api returned a matching shape
        return args["dataInstanceShape"]

    if re.search('Standard', shape.shape):
      if shape.shape not in standardio:
        if re.search('Cluster', shape.shape):
          # SKIP ClusterNode shapes
          continue
        standardio.append(str(shape.shape))
    elif re.search('DenseIO', shape.shape):
      if shape.shape not in denseio:
        denseio.append(shape.shape)
    else:
      if shape.shape not in other:
        other.append(shape.shape)

  if args["dataInstanceShape"]:
    # we would have already returned a matching shape if the api returned it
    print("\nERROR: VM shape '" + args["dataInstanceShape"] + "' not found.\n\nProvide a valid shape and run again.\n")
    sys.exit(1)

  print("\n**** Fast IO [NVMe disk]\n")
  print('{0:<20} | {1:<7} | {2:>4} | {3:>7}'.format("Shape","Memory","OCPU","DB SIZE"))
  sys.stdout.write('-' * 47 + "\n\n")

  order = {}
  counter = None
  for i, d in enumerate(supported_denseio,start=1):
    order[int(i)] = str(d)
    counter = i + 1
    ocpu = supported_denseio[d][0]
    memory = supported_denseio[d][1]
    dbsize = int(memory/2)
    if not filter(lambda shape: shape == d, denseio):
      shape_missing = 1
      default = None
    else:
      print('{0:<20} | {1:<7} | {2:>4} | {3:>7}'.format(str(int(i)) + ". " + d,str(memory) + ' GB',str(ocpu),str(dbsize) + ' GB'))

  print("\n**** Standard IO [Block Storage]\n")

  print('{0:<20} | {1:<7} | {2:>4} | {3:>7}'.format("Shape","Memory","OCPU","DB SIZE"))
  sys.stdout.write('-' * 47 + "\n\n")
  for i, d in enumerate(supported_stdio,start=counter):
    order[int(i)] = str(d)
    ocpu = supported_stdio[d][0]
    memory = supported_stdio[d][1]
    dbsize = int(memory/2)
    if not filter(lambda shape: shape == d, standardio):
      shape_missing = 1
      default = None
    else:
      print('{0:<20} | {1:<7} | {2:>4} | {3:>7}'.format(str(int(i)) + ". " + d,str(memory) + ' GB',str(ocpu),str(dbsize) + ' GB'))

  print("\nNOTE: Please check the OCI console's \"Governance->Service Limits\" or \"Tenancy->Service Limits\" page\n" + " " * 6 + \
        "to ensure that you have sufficient resources to provision the desired VM shape.\n")

  while True:
    if args["batch"]:
      answer = default
    else:
      if default == None:
        answer = raw_input("\nChoose the shape for data instances : ")
      else:
        answer = raw_input("\nChoose the shape for data instances [ " + str(default) + " ] ")

    if answer == '':
      if default != None:
        answer = default

    if re.match("^([0-9]+)$", answer):
      if order.get(int(answer)):
        return order.get(int(answer))
      if match != None:
        break
      else:
        print("Choose a valid number for the desired shape.")
    else:
      print("Choose a valid number for the desired shape.")

  if match != None:
    return match


######################################################################
# test_api
######################################################################
def test_api(config):

  try:
    identity = oci.identity.IdentityClient(config)
    response = identity.list_compartments(config["tenancy"])
    return True
  except:
    return False

######################################################################
# get_compartment
######################################################################
def get_compartment(config):

  compartments = []
  answer = ''

  try:
    identity = oci.identity.IdentityClient(config)
    response = oci.pagination.list_call_get_all_results(identity.list_compartments,config["tenancy"])
  except Exception as err:
    print("\nERROR: Failed to request list of compartments from OCI.\n\n\"%s\n\"" % str(err))
    sys.exit(1)

  for compartment in response.data:
    if str(compartment.lifecycle_state) == "ACTIVE":
      if str(compartment.name) == "ManagedCompartmentForPaaS":
        continue
      compartments.append(compartment)

  if len(compartments):
    print("\nOf the following " + str(len(compartments)) + " compartments :\n")

    for counter, compartment in enumerate(compartments,start=1):
      if args["compartment"]:
        if compartments[counter-1].name == args["compartment"]:
          answer = counter
      print(str(counter) + '. ' + compartments[counter-1].name)

    while True:
      try:
        if args["compartment"]:
          if not answer:
            print("\nERROR: Compartment '" + args["compartment"] + "' not found. Provide a valid compartment name and try again.\n")
            sys.exit(1)
        elif args["batch"]:
          answer = 1
        else:
          answer = raw_input("\nWhich compartment would you like to use ? [ 1 ] ")

        if answer == '':
          answer = 1

        if not re.match("^([0-9]+)$", str(answer)):
          print("\nProvide a compartment from the list provided.")
          continue

        compartment = compartments[int(answer)-1]
        break

      except IndexError as error:
        print("\nInvalid compartment selected.\n")
        continue
  else:
    print("\nERROR: No valid compartments detected. Exiting.\n")
    sys.exit(1)

  return { "name": compartment.name, "id": compartment.id }


###############################################
# get_region
###############################################
def get_region(config,compartment_id):


  try:
    identity = oci.identity.IdentityClient(config)
    response = identity.list_region_subscriptions(config["tenancy"])
  except Exception as err:
    print("\nERROR: Failed to request list of regions from OCI.\n\n\"%s\n\"" % str(err))
    sys.exit(1)

  answer = ''
  regions = []
  default = 1

  for region in response.data:
    if str(region.status) == "READY":
      regions.append(region)

  if len(regions):
    print("\nOf the following " + str(len(regions)) + " regions :\n")
    for counter, region in enumerate(regions,start=1):
      if regions[counter-1].region_name == config["region"]:
        default = str(counter)
      if args["region"]:
        if regions[counter-1].region_name == args["region"]:
          answer = counter
      print(str(counter) + '. ' + regions[counter-1].region_name)

    while True:
      try:
        if args["region"]:
          if not answer:
            print("\nERROR: The region '" + args["region"] + "' could not be found. Provide a valid region name and try again.\n")
            sys.exit(1)
        elif args["batch"]:
          if default:
            answer = default
            break
          else:
            answer = 1
        else:
          answer = raw_input("\nWhich region would you like to use ? [ " + default + " ] ")

        if answer == '':
          answer = default

        if not re.match("^([0-9]+)$", str(answer)):
          print("\nSorry, please provide a region from the list provided.")
          continue

        region = regions[int(answer)-1]
        break
      except IndexError as error:
        print("\nInvalid region selected!")
        continue
  else:
    print("\nERROR: No valid regions detected! Exiting!\n")
    sys.exit(1)

  return str(region.region_name)


####################################################################
# is_trial_account
# - determine whether user has an OCI trial or pay-as-you-go account
####################################################################
def is_trial_account():

  default = 'no'
  answer = ''

  while True:
    if args["trialAccount"]:
      answer = "yes"
      break
    elif args["batch"]:
      answer = default
      break
    else:
      answer = raw_input("\nAre you using an OCI trial or pay-as-you-go account ? [ " + default + " ] ")

    if answer == '':
      answer = default
      break
    elif answer.lower() in ('y','yes'):
      answer = 'yes'
      break
    elif answer.lower() in ('n','no'):
      answer = 'no'
      break
    else:
      print("\nPlease answer 'yes' or 'no'.")
      continue

  return answer


###############################################
# get_bastion_ip
# - DETERMINE PUBLIC IP ADDRESS OF BASTION SERVER
###############################################
def get_bastion_ip(config,compartment_id,service_name,type):

  compute = oci.core.ComputeClient(config)
  response = oci.pagination.list_call_get_all_results(compute.list_instances,compartment_id)
  for instance in response.data:
    if instance.display_name == service_name + "-bs-001":
      vnics = compute.list_vnic_attachments(compartment_id=compartment_id,instance_id=instance.id)
      for vnic in vnics.data:
        if vnic.lifecycle_state == "ATTACHED":
          network_obj = oci.core.VirtualNetworkClient(config)
          vnic_det = network_obj.get_vnic(vnic_id=vnic.vnic_id)
          if vnic_det.data.public_ip != None:
            ip = vnic_det.data.public_ip
            return ip

  return None

######################################################################
# get_local_provider_version
######################################################################
def get_local_provider_version(dir):

  for root, dirnames, filenames in os.walk(dir):
    for filename in fnmatch.filter(filenames, 'terraform-provider-oci_v*'):
      m = re.search("terraform-provider-oci_v([\w|\.]+)", str(filename))
      if m:
        return (m.group(1), os.path.join(root, filename))

  return (None, None)


######################################################################
# get_terraform_version
######################################################################
#
# Searches PATH + timesten_bin for the terraform executable
#
# Returns the version and abs path of the terraform executable
#
def get_terraform_version():

  terraform_bin = None
  paths = os.environ["PATH"].split(os.pathsep)

  if os.path.exists(str(os.getenv("HOME") + "/.oci")):
    # there are cloud docs that suggest terraform might be here
    paths.append(str(os.getenv("HOME") + "/.oci"))

  if timesten_bin:
    paths.append(timesten_bin)

  for path in paths:
    if os.path.exists(path + '/terraform'):
      terraform_bin = os.path.join(path, 'terraform')
      break

  try:
    out = subprocess.check_output([terraform_bin,'--version'])
    m = re.match("^Terraform v([\w|\.]+)", out.decode("utf-8"))
    if m:
      return m.group(1),terraform_bin
    else:
      print("- ERROR : Cannot determine Terraform version!")
  except:
    print("- Cannot locate a Terraform executable.")

  return None,None


######################################################################
# find_oci_provider
######################################################################
#
# Searches PATH + timesten_bin for the terraform OCI provider executable
#
# Returns the version and abs path of the terraform OCI provider executable
#
def find_oci_provider():

  provider_bin = None
  terraform_plugin_dir = str(os.getenv("HOME")) + '/.terraform.d/plugins'
  paths = os.environ["PATH"].split(os.pathsep)
  # look in the existing plugin dir first
  paths.insert(0, terraform_plugin_dir)
  # look in our local timesten bin dir
  if timesten_bin:
    paths.append(timesten_bin)

  for path in paths:
    (ver, filename) = get_local_provider_version(path)
    if filename:
      return (ver, filename)
    else:
      continue

  return (None, None)

######################################################################
# service_name_ok
######################################################################
def service_name_ok(name,oci_config):

  if len(name) > 12:
    return False
  elif re.search("[^a-zA-Z0-9]+",name):
    # cannot contain non-alphanumeric values
    # TT allows - and _, but on OCI we create VCNs with the service name
    # and VCNs do not allow non-alphanumeric values
    return False
  else:
    # check for an existing service with the same name
    res = get_resources(oci_config,name)
    if res:
      for resource in sorted(res, key=itemgetter('type')):
        if resource["type"].lower() == "instance" \
           or resource["type"].lower() == "block volume" \
           or resource["type"].lower() == "boot volume":
          if re.search("^" + name + "-", resource["name"].lower()):
            print("\nA service with that name already exists!")
            return False

  return True

######################################################################
# get_service_name
######################################################################
def get_service_name(oci_config):

  default_service_name = "timesten" + str(randint(0, 999))

  while True:
    if args["serviceName"]:
      answer = args["serviceName"]
      if not service_name_ok(answer,oci_config):
        print("\nProvide a valid service name (alphanumeric only, max 12 characters).")
        sys.exit(1)
      break
    elif args["batch"]:
      answer = default_service_name
      if not service_name_ok(answer,oci_config):
        print("\nProvide a valid service name (alphanumeric only, max 12 characters).")
        sys.exit(1)
      break

    answer = raw_input("\nWhat would you like to name this service : [ " + default_service_name + " ] ")

    if answer == '':
      answer = default_service_name
    else:
      answer = answer.strip()

    if not service_name_ok(answer,oci_config):
      print("\nProvide a valid service name (alphanumeric only, max 12 characters).")
      continue
    else:
      break

  return answer


######################################################################
# get_os_image
######################################################################
def get_os_image(config,compartment_id):

  images = []
  compute = oci.core.ComputeClient(config)

  try:
    response = oci.pagination.list_call_get_all_results(compute.list_images,compartment_id,sort_order='DESC') # operating_system='Oracle Linux',operating_system_version='7.5'
  except Exception as err:
    print("\nERROR: Failed to obtain list of compute images from OCI.\n\n\"%s\n\"" % str(err))
    sys.exit(1)

  for image in response.data:
    #print('Image: {}'.format(image.display_name))
    if re.search("Oracle-Linux-7",image.display_name):
      if re.search("GPU",image.display_name):
        continue
      if args["osImage"]:
        if args["osImage"] == image.display_name:
          return image
      else:
        # return the first image (most recent)
        return image

  if args["osImage"]:
    print("\nERROR: Invalid OS image passed : '" + args["osImage"] + "'.\n")
    sys.exit(1)

######################################################################
# find_terraform
# - find the terraform binary
######################################################################
def find_terraform(oci_config):

  print("\nChecking Terraform installation ...")
  terraform_version,terraform_bin = get_terraform_version()
  if terraform_version != None:
    print("- OK : Terraform version " + terraform_version + " in " + terraform_bin + "\n")
    return terraform_bin
  else:
    print("\n" + '-' * 80 + "\n")
    print("To install Terraform, run the following command :\n\n" + \
          "\tsudo yum install -y terraform\n")
    print('-' * 80 + "\n")
    sys.exit(1)

  return terraform_bin


######################################################################
# get_bootstrap_metadata
######################################################################
def get_bootstrap_metadata():

  cmd = "curl -m 10 -s -L http://169.254.169.254/opc/v1/instance/"
  try:
    out = subprocess.check_output(cmd,shell=True,stderr=subprocess.STDOUT)
    meta = json.loads(out)
    if "canonicalRegionName" in meta:
      return meta
  except subprocess.CalledProcessError as e:
    #print("\nERROR: Failed to acquire VM's metadata (not running in OCI?).") # + e.output.decode("utf-8"))
    return None

######################################################################
# get_tt_version
######################################################################
def get_tt_version():

  version = ''

  if os.path.exists(os.getcwd() + '/../bin/ttVersion'):
    try:
      out = subprocess.check_output(os.getcwd() + '/../bin/ttVersion', shell=True)
      # TimesTen Release 18.1.1.3.0 (64 bit Linux/x86_64) (timesten.conf not found) 2018-09-27T20:42:24Z
      m = re.search("TimesTen Release ([\d|\.]+)\s", out)
      if m.group(1):
        version = m.group(1).translate(None, '.')
    except subprocess.CalledProcessError as err:
      print("\nERROR: Failed to execute " + os.getcwd() + "/../bin/ttVersion\n")
      sys.exit(1)

  if not version:
    print("\nERROR: Failed to determine TimesTen Scaleout version.\n")
    sys.exit(1)

  return version


######################################################################
# create_scaleout_distro
######################################################################
def create_scaleout_distro():

  distro_root = path.abspath(path.join(__file__ ,"../../.."))
  distro_basename = os.path.basename(path.abspath(path.join(__file__ ,"../..")))

  if not current_tt_version:
    print("\nERROR: Cannot determine current TimesTen Scaleout version!\n")
    sys.exit(1)

  distro_loc = tf_script_home + "/service/packages/timesten" + current_tt_version + ".server.linux8664.zip"

  try:
    print("\nGenerating TimesTen Scaleout distribution ...")
    zip_cmd = "cd " + distro_root + " && zip -rq " + distro_loc + " " + distro_basename
    subprocess.check_output(zip_cmd, shell=True)
  except subprocess.CalledProcessError as err:
    os.remove(distro_loc)
    print("\nERROR: Failed to generate distribution. rv=" +  str(err.returncode) + "\n")
    sys.exit(1)

  return distro_loc


######################################################################
# find_scaleout_scripts
######################################################################
def find_scaleout_scripts(oci_config):

  existing_script_archive = None
  existing_script_count = 0
  tf_script_home = None
  search_path = os.getcwd()
  print("\nChecking TimesTen scripts ...")
  if os.path.exists(os.getcwd() + '/env-vars'):
    tf_script_home = os.getcwd()
  else:
    for dirname, dirnames, filenames in os.walk(search_path):
      for filename in filenames:
        if re.search("^terraform_scaleout_\d", filename):
          existing_script_count += 1
          if existing_script_count > 1:
            print("\nERROR: You have more than one TimesTen Scaleout Terraform script release in " + os.getcwd() + ".\n\n" +
                  "Please make sure there is only one TimesTen Scaleout Terraform script release in this directory and run this utility again.\n")
            sys.exit(1)
          else:
            existing_script_archive = dirname + "/" + filename
    if existing_script_archive is not None:
      print("Extracting " + existing_script_archive + " ...")
      subprocess.call(["unzip", "-qo", existing_script_archive,"-d",timesten_bin])
      if os.path.exists(timesten_bin + '/ottscaleout'):
        tf_script_home = timesten_bin + '/ottscaleout'
      else:
        print("\nERROR: Failed to extract TimesTen Scaleout Terraform scripts!\n")
        sys.exit(1)

  if not tf_script_home:
    print("\nCannot locate the TimesTen Scaleout Terraform scripts.")
    print("\nPlease place this utility inside a Scaleout Terraform scripts directory and run again.\n")
    sys.exit(1)

  ttscaleout_scripts_version = dump_version()
  if ttscaleout_scripts_version:
    print("- OK : scripts version " + ttscaleout_scripts_version + " installed.")
  else:
    print("- OK : scripts located in " + tf_script_home)

  return tf_script_home


######################################################################
# get_scaleout_distro
######################################################################
def get_scaleout_distro(oci_config):

  distros = []
  answer = ''
  existing_distro = None
  default_distro_answer = '1'
  default_use_existing = 'y'
  default_obj_name = None
  existing_distro_count = 0
  packages_dir = tf_script_home + "/service/packages"
  search_paths = (packages_dir,timesten_bin)

  if args["distro"]:
    if not os.path.exists(args["distro"]):
      print("\nERROR: The path " + args["distro"] + " does not not exist.")
      sys.exit(1)
    elif os.path.dirname(os.path.abspath(args["distro"])) == packages_dir:
      return args["distro"]
    else:
      try:
        shutil.copy2(args["distro"], packages_dir)
      except IOError as e:
        print("ERROR: Failed to copy distribution from " + args["distro"] + " to " + packages_dir + ".\n\nReason: " + str(e))
        sys.exit(1)
      print("\nUsing the TimesTen Scaleout distribution in " + args["distro"] + "\n")
      return args["distro"]

  for dirname, dirnames, filenames in chain.from_iterable(os.walk(path) for path in search_paths):
    if re.search("_destroyed", dirname):
      continue
    for filename in filenames:
      if re.search("^timesten\d", filename):
        existing_distro = os.path.join(dirname, filename)
        distros.append({"display_name":filename})
        break

  if existing_distro is not None:
    print("\nFound an existing TimesTen Scaleout distribution :\n\n" + existing_distro + "\n")
    if args["batch"]:
      answer = default_use_existing
    else:
      answer = raw_input("Would you like to use this TimesTen Scaleout distribution ? [ " + default_use_existing + " ] ")

    if answer.lower() in ('y','yes',''):
      if not os.path.dirname(existing_distro) == packages_dir:
        try:
          shutil.copy2(existing_distro, packages_dir)
        except IOError as e:
          print("ERROR: Failed to copy distribution from " + existing_distro + " to " + packages_dir + ".\n\nReason: " + str(e))
          sys.exit(1)
      return distros[0]

  if not args["batch"]:
    # ask the user for the location of the scaleout distro
    while True:
      answer = raw_input("\nProvide the location of the TimesTen Scaleout distribution : ")
      if answer == '':
        print("\nProvide a valid path.")
        continue
      else:
        if not os.path.exists(answer):
          print("\nFile '" + answer + "' does not exist.")
          continue
        else:
          try:
            shutil.copy2(answer, packages_dir)
          except IOError as e:
            print("ERROR: Failed to copy distribution from " + answer + " to " + packages_dir + ".\n\nReason: " + str(e))
            sys.exit(1)
          return answer


######################################################################
# setup_ssh
######################################################################
def setup_ssh():

  print("\nChecking SSH configuration")
  if not os.path.exists(home_dir + "/.ssh/id_rsa") or not os.path.exists(home_dir + "/.ssh/id_rsa.pub"):
    print("\nERROR: This utility requires valid RSA SSH keys installed in " + home_dir + "/.ssh\n")
    if args["batch"]:
      answer = 'y'
      print("Creating ssh keys in " + home_dir + "/.ssh/id_rsa ...\n")
    else:
      answer = raw_input("Would you like to create the ssh keys now ? [y] ")
    if answer.lower() in ('y','yes',''):
      subprocess.call("ssh-keygen -t rsa -N \"\" -f ~/.ssh/id_rsa -P \"\" > /dev/null", shell=True)
    else:
      print("\nValid SSH keys are required. SSH keys can be created by running :\n\n\tssh-keygen -t rsa\n\n")
      sys.exit(1)

    print("- OK : SSH keys located in " + home_dir + "/.ssh")


######################################################################
# copy_scaleout_scripts
######################################################################
def copy_scaleout_scripts(service_name):

  if os.path.exists(tf_script_home + "/env-vars"):

    backup_dir = timesten_bin + "/" + service_name
    if os.path.exists(backup_dir):
      backup_dir = timesten_bin + "/" + service_name + "_" + str(time.strftime("%Y%m%d_%H_%M_%S"))
      print("\nINFO: " + timesten_bin + "/" + service_name + " exists. Creating " + backup_dir)

    try:
      os.makedirs(backup_dir)
      copy_tree(tf_script_home, backup_dir)
      # copy this script to the backup dir (it can be executed there)
      if os.path.exists(os.path.realpath(__file__)):
        shutil.copy2(os.path.realpath(__file__), backup_dir)
    except IOError as e:
      print("ERROR: Failed to copy " + tf_script_home + " to " + backup_dir + ".\n\nReason: " + str(e))

    return backup_dir

  else:
    print("\nWARNING: Failed to copy " + tf_script_home + " to " + backup_dir + \
          ".\n\nReason: " + tf_script_home + "/env-vars does not exist.\n")


######################################################################
# remove_terraform_dir
######################################################################
def remove_terraform_dir():

  # remove the temp script dir since we're exiting the script without provisioning
  if not args["useLocal"] \
     and os.path.exists(tf_script_home) \
     and tf_script_home == timesten_bin + "/" + service_name:

    print("Removing " + tf_script_home)
    remove_tree(tf_script_home)


######################################################################
# cleanup_terraform_dir
######################################################################
def cleanup_terraform_dir():

  # remove and re-create service/packages dir
  if os.path.exists(tf_script_home + "/service/packages"):
    # remove packages dir (too big)
    remove_tree(tf_script_home + "/service/packages")
    os.makedirs(tf_script_home + "/service/packages")


######################################################################
# setup_oci_conf
######################################################################
def setup_oci_conf():

  # $HOME/.oci/config file
  #
  #[DEFAULT]
  #user=ocid1.user.xxx
  #fingerprint=a1:..
  #key_file=/home/xxx/.oci/oci_api_key.pem
  #tenancy=ocid1.xxx
  #region=xxx

  print("\nChecking OCI API configuration ...")
  if not os.path.exists(oci_config_file):
    print("\nThe file " + oci_config_file + " could not be found.\n\n" +
          "This utility requires valid OCI API credentials. See the following links for more information :\n\n" +
          "https://docs.cloud.oracle.com/iaas/Content/API/Concepts/sdkconfig.htm\nhttps://docs.cloud.oracle.com/iaas/Content/API/Concepts/apisigningkey.htm\n")

    print("To complete the OCI API configuration, follow these steps :\n\n1) Run 'sudo yum install -y python-oci-cli' " + \
          "(installs the OCI command line utility)\n2) Run 'oci setup config'\n3) Copy the generated public key to the OCI console " + \
          "(default key location is ~/.oci/oci_api_key_public.pem)\n4) Run this utility again.\n")
    sys.exit(1)


######################################################################
# process_tfstate
# - process Terraform state file
######################################################################
def process_tfstate(file):

  instances = []
  bastion_instances = []
  mgmt_instances = []
  data_instances = []
  zk_instances = []

  with open(file) as data_file:
    data = json.load(data_file)

  for res in data["modules"][0]["resources"]:
    # oci_core_instance.di_instance.0
    if re.search("^oci_core_instance", res):
      instance_data = data["modules"][0]["resources"][res]["primary"]["attributes"]
      if re.search("-bs-\d+", instance_data["display_name"]):
        bastion_instances.append({ "display_name":instance_data["display_name"],
                           "public_ip" :instance_data["public_ip"],
                           "private_ip":instance_data["private_ip"],
                           "shape"     :instance_data["shape"]})

      instances.append({ "display_name":instance_data["display_name"],
                           "public_ip" :instance_data["public_ip"],
                           "private_ip":instance_data["private_ip"],
                           "shape"     :instance_data["shape"]})

  if not bastion_instances:
    print("\n\nERROR: Cannot determine bastion instance(s)!\n")
    return
  else:
    first_bastion = bastion_instances[0]

  # set service_name if not defined
  try:
    service_name
  except:
    m = re.match("(.+)-bs", first_bastion["display_name"])
    if m:
      #print("parsed service name is " + m.group(1))
      service_name =  m.group(1)

  # set tf_script_home if not defined
  try:
    tf_script_home
  except:
    tf_script_home = os.path.dirname(file)

  # set ansible_status if not defined
  try:
    ansible_status
  except:
    ansible_status = 0

  # determine data instances
  for instance in sorted(instances, key=lambda x: int(re.search(r'\d+$',x["display_name"]).group())):
    # don't modify instances list
    instance2 = instance.copy()
    # skip bastion
    if re.search("-bs-\d+", instance2["display_name"]):
      continue
    elif re.search("-zk-\d+", instance2["display_name"]):
      continue

    ls_data =   "ssh -oStrictHostKeyChecking=no -oBatchMode=yes -J opc@" + first_bastion["public_ip"] + \
                " opc@" + instance2["display_name"] + " \"ls /u10/TimesTen/" + service_name + "\" 2>/dev/null"
    try:
      out = subprocess.check_output(ls_data, shell=True).splitlines()
      for line in out:
        m = re.match("^(instance\d+)$", line)
        if m:
          instance2["path"] = "/u10/TimesTen/" + service_name + "/" +  m.group()
    except subprocess.CalledProcessError as err:
      print("\nAn error was encountered while generating the summary report. No summary report will be produced.\n\nError was :\n\n" + str(err))
      return
    data_instances.append(instance2)

  if not data_instances:
    print("\n\nERROR: Cannot determine data instance2(s)!\n")
    return
  else:
    first_data_instance = data_instances[0]

  # determine management instances
  for instance in sorted(instances, key=lambda x: int(re.search(r'\d+$',x["display_name"]).group())):
    # don't modify instances list
    instance3 = instance.copy()
    if re.search("-bs-\d+", instance3["display_name"]):
      continue
    elif re.search("-zk-\d+", instance3["display_name"]):
      continue

    is_mgmt = "ssh -oStrictHostKeyChecking=no -oBatchMode=yes opc@" + first_bastion["public_ip"] + \
          " \"nc -zv -w 1 " + instance3["display_name"] + " 6624-6625\" 2>/dev/null"
    sys.stdout.flush()
    process = subprocess.Popen(is_mgmt, stdout=subprocess.PIPE, shell=True)
    stdout, stderr = process.communicate()
    status = process.wait()
    if status == 0:
      ls_mgmt =   "ssh -oStrictHostKeyChecking=no -oBatchMode=yes -J opc@" + first_bastion["public_ip"] + \
                  " opc@" + instance3["display_name"] + " \"ls /u10/TimesTen/" + service_name + "\" 2>/dev/null"
      try:
        out = subprocess.check_output(ls_mgmt, shell=True).splitlines()
        for line in out:
          m = re.match("^([\w|_]+)$", line)
          if m.group(1):
            instance3["path"] = "/u10/TimesTen/" + service_name + "/" +  m.group(1)
      except subprocess.CalledProcessError as err:
        return
      mgmt_instances.append(instance3)

  if not mgmt_instances:
    print("\n\nERROR: Cannot determine management instance(s)!\n")
    return
  else:
    first_mgmt_instance = mgmt_instances[0]

  # determine zookeeper instances
  if os.path.exists(tf_script_home + "/ansible.out"):
    f = open(tf_script_home + "/ansible.out", "r")
    for line in f:
      if re.search("Zookeeper is running on ", line):
        m = re.match(".+Zookeeper is running on (.+):(\d+);.+directory:\s(.+)\"",line)
        if m and m.group(1) and m.group(2) and m.group(3):
          zk_instances.append({ "display_name":m.group(1),
                                        "port":m.group(2),
                                   "directory":m.group(3)})
    f.close()

  ###############################
  # DISPLAY SERVICE INFO
  ###############################

  if os.path.exists(tf_script_home + '/scaleout.out'):
    os.remove(tf_script_home + '/scaleout.out')

  destination = open(tf_script_home + '/scaleout.out', "w" )

  # BASTION INSTANCES
  destination.write("\n" + '#' * 40)
  destination.write("\n# Bastion Hosts\n")
  destination.write('#' * 40 + "\n\n")
  destination.write("{:<20}{:<17}{:<17}{:<15}\n".format("Hostname", "Public IP",  "Private IP", "Shape"))
  destination.write("{:<20}{:<17}{:<17}{:<15}\n".format("--------------------","---------------" ,"---------------", "---------------"))
  for bastion in sorted(bastion_instances, key=lambda x: int(re.search(r'\d+$',x["display_name"]).group())):
    destination.write("{:<20}{:<17}{:<17}{:<15}\n".format(bastion["display_name"], bastion["public_ip"], bastion["private_ip"], bastion["shape"]))

  # MGMT INSTANCES
  destination.write("\n" + '#' * 40)
  destination.write("\n# Management Instances\n")
  destination.write('#' * 40 + "\n\n")
  destination.write("{:<20}{:<17}{:<17}{:<15}\n".format("Hostname", "Public IP",  "Private IP", "Shape"))
  destination.write("{:<20}{:<17}{:<17}{:<15}\n".format("--------------------","---------------" ,"---------------", "---------------"))

  for instance in sorted(mgmt_instances, key=lambda x: int(re.search(r'\d+$',x["display_name"]).group())):
    if re.search("-bs-\d+", instance["display_name"]):
      continue
    destination.write("{:<20}{:<17}{:<17}{:<15}\n".format(instance["display_name"], instance["public_ip"], instance["private_ip"], instance["shape"]))

  # DATA INSTANCES
  destination.write("\n" + '#' * 40)
  destination.write("\n# Data Instances\n")
  destination.write('#' * 40 + "\n\n")
  destination.write("{:<20}{:<17}{:<17}{:<15}\n".format("Hostname", "Public IP",  "Private IP", "Shape"))
  destination.write("{:<20}{:<17}{:<17}{:<15}\n".format("--------------------","---------------" ,"---------------", "---------------"))

  for instance in sorted(instances, key=lambda x: int(re.search(r'\d+$',x["display_name"]).group())):
    # skip the bastion and any zookeeper instances
    if re.search("-bs-\d+", instance["display_name"]):
      continue
    elif re.search("-zk-\d+", instance["display_name"]):
      continue
    destination.write("{:<20}{:<17}{:<17}{:<15}\n".format(instance["display_name"], '', instance["private_ip"], instance["shape"]))

  # ZOOKEEPER INSTANCES
  if zk_instances:
    destination.write("\n" + '#' * 40)
    destination.write("\n# Zookeeper Instances\n")
    destination.write('#' * 40 + "\n\n")
    destination.write("{:<22}{:<10}{:<15}\n".format("Hostname", "Port", "Directory"))
    destination.write("{:<22}{:<10}{:<15}\n".format("-------------------","----" ,"---------------------------"))

    for instance in sorted(zk_instances, key=lambda x: int(re.search(r'\d+$',x["display_name"]).group())):
      # skip the bastion and any zookeeper instances
      destination.write("{:<22}{:<10}{:<15}\n".format(instance["display_name"], instance["port"], instance["directory"]))

  # run these commands if ansible succeeded (grid provisioned)
  try:
    if ansible_status == 0:
      mgmt_status =  "ssh -oStrictHostKeyChecking=no -oBatchMode=yes -J opc@" + first_bastion["public_ip"] + \
                      " opc@" + first_mgmt_instance["display_name"] + " \"cd /tmp && sudo -u oracle " + first_mgmt_instance["path"] + \
                      "/bin/ttenv ttgridadmin mgmtStatus\" 2>/dev/null"

      sys.stdout.flush()
      process = subprocess.Popen(mgmt_status, stdout=subprocess.PIPE, shell=True)
      stdout, stderr = process.communicate()
      status = process.wait()
      if status == 0:
        destination.write("\n" + '#' * 80 + "\n")
        destination.write("#\n# [ from management instance " +  first_mgmt_instance["display_name"] + " ]\n#\n#\tsudo -u oracle " + first_mgmt_instance["path"] + "/bin/ttenv ttGridAdmin mgmtStatus\n#")
        destination.write("\n" + '#' * 80 + "\n\n")
        destination.write(stdout)

      db_status = "ssh -oStrictHostKeyChecking=no -oBatchMode=yes -J opc@" + first_bastion["public_ip"] + \
                  " opc@" + first_mgmt_instance["display_name"] + " \"cd /tmp && sudo -u oracle /u10/TimesTen/"  + \
                  service_name + "/iron_mgmt*/bin/ttenv ttgridadmin dbStatus -all\" 2>/dev/null"

      sys.stdout.flush()
      process = subprocess.Popen(db_status, stdout=subprocess.PIPE, shell=True)
      stdout, stderr = process.communicate()
      status = process.wait()
      if status == 0:
        destination.write("\n" + '#' * 80 + "\n")
        destination.write("#\n# [ from management instance " + first_mgmt_instance["display_name"] + " ]\n#\n#\tsudo -u oracle " + first_mgmt_instance["path"] + "/bin/ttenv ttGridAdmin dbStatus -all\n#")
        destination.write("\n" + '#' * 80 + "\n\n")
        destination.write(stdout)
        destination.write("\n" + '#' * 80 + "\n\n")

      destination.write("\nTo connect to the bastion host :\n\n\tssh opc@" + first_bastion["public_ip"])
      destination.write("\n\nTo connect to a data instance through the bastion host :\n\n\tssh -J opc@" + first_bastion["public_ip"] + \
                       " opc@" + first_data_instance["display_name"])

      destination.write("\n\nTo connect to the database :\n\n\tStep 1 : ssh -J opc@" + first_bastion["public_ip"] + \
                       " opc@" + first_data_instance["display_name"] + "\n\tStep 2 : sudo -u oracle " + first_data_instance["path"] + \
                       "/bin/ttIsql " + service_name)

      destination.write("\n\n\n")
      destination.write('#' * 80 + "\n\n")

      destination.write("All configuration files used to create this service have been written to :\n\n\t" + tf_script_home + "\n\n")
      destination.write("This directory should be retained until the service is destroyed.\n\n")
      destination.write("To destroy the service :\n\n\tcd " + tf_script_home + " && ./" + os.path.basename(__file__) + " -destroy\n\n")

      destination.close()

  except NameError as err:
    return

  # display the file we just created
  f = open(tf_script_home + '/scaleout.out', "r")
  outfile = f.read()
  print(outfile)
  f.close()

  print("The summary data above was written to " + tf_script_home + "/scaleout.out\n\n")


######################################################################
# get_resources
# - query oci for resources matching the passed service name
######################################################################
def get_resources(config, svcname):

  resources = []

  search_client = oci.resource_search.ResourceSearchClient(config)

  try:

    search = oci.resource_search.models.FreeTextSearchDetails(text=svcname,
                                                            type='FreeText',
                                                            matching_context_type=oci.resource_search.models.SearchDetails.MATCHING_CONTEXT_TYPE_HIGHLIGHTS)

  except Exception as err:
    print("\nERROR: Failed to request list of resources from OCI!\n\n\"%s\n\"" % str(err))
    return False

  for response in oci.pagination.list_call_get_all_results_generator(search_client.search_resources, 'response', search):
      for resource in response.data.items:
        # get all resources that are not in terminated state
        if resource.lifecycle_state.lower() != 'terminated':
          if resource.resource_type.lower() == 'volume':
            type = 'Block Volume'
          elif resource.resource_type.lower() == 'bootvolume':
            type = 'Boot Volume'
          elif resource.resource_type.lower() == 'bootvolume':
            type = 'Virtual Network (VNC)'
          else:
            type = resource.resource_type

          # match the passed service name
          if re.search("^" + svcname.lower() + "-", resource.display_name.lower()):
            resources.append({  "type": type,
                                "name": resource.display_name,
                                "state": resource.lifecycle_state,
                             })

  if resources:
    return resources
  else:
    return False

######################################################################
# list_resources
# - display resources matching the passed sercice name
######################################################################
def list_resources(config, svcname, save=0):

  resources = get_resources(config, svcname)

  if resources:

    fd, tmpfile = mkstemp()
    with open(tmpfile, 'w') as f:
      f.write("\n" + '#' * 60 + "\n")
      f.write("# Provisioned Resources as of " + str(datetime.now()))
      if save:
        f.write("\n# see " + tf_script_home + '/resources_provisioned.out' + "\n")
      else:
        f.write("\n")
      f.write('#' * 60 + "\n\n")
      f.write("{:<20}{:<17}{:<17}\n".format("Type", "State",  "Name")),
      f.write('-' * 50 + "\n")
      for resource in sorted(resources, key=itemgetter('type')):
        f.write("{:<20}{:<17}{:<17}\n".format(resource["type"], resource["state"], resource["name"])),
      f.close()
      os.close(fd)
      # display the file we just created
      f = open(tmpfile, "r")
      outfile = f.read()
      print(outfile)
      f.close()

      if save:
        if os.path.exists(tf_script_home + '/resources_provisioned.out'):
          shutil.move(tf_script_home + '/resources_provisioned.out',tf_script_home + '/resources_provisioned.old')
        shutil.move(tmpfile,tf_script_home + '/resources_provisioned.out')
      else:
        os.remove(tmpfile)

    return True

  else:
    return False


######################################################################
# dump_version
# - display script version as indicated in the README
######################################################################
def dump_version():

  version = 'Unknown'
  if os.path.exists(os.getcwd() + '/README.md'):
    readme = open(os.getcwd() + '/README.md', "r" )
    for line in readme:
      # Version v3_181205_18.1.2.0.0
      m = re.match("^\#+ Version ([\w\-|\.]+)", line)
      if m and m.group(1):
        version = m.group(1)
        break

    if args["version"]:
      print("\nRunning version : " + version + "\n")

    return version


if __name__ == "__main__":

  try:
    main()
  except Exception as err:
    sys.stderr.write("\nEXITING WITH ERROR: %s\n" % str(err))
    sys.exit(1)

